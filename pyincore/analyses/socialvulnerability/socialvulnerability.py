# Copyright (c) 2021 University of Illinois and others. All rights reserved.
#
# This program and the accompanying materials are made available under the
# terms of the Mozilla Public License v2.0 which accompanies this distribution,
# and is available at https://www.mozilla.org/en-US/MPL/2.0/

import numpy as np
import pandas as pd
import censusdata
import sys

from pyincore import BaseAnalysis
from pyincore.analyses.socialvulnerability.socialvulnerabilityutil import SocialVulnerabilityUtil

class SocialVulnerability(BaseAnalysis):
    """This analysis computes a social vulnerability score for per associated zone in census data.

    The output of the computation is a dataset CSV format.

    Contributors
        | Science: Elaina Sutley, Amin Enderami
        | Implementation:  Amin Enderami, Santiago Núñez-Corrales, and NCSA IN-CORE Dev Team

    Related publications

    Args:
        incore_client (IncoreClient): Service authentication.

    """

    def __init__(self, incore_client):
        super(SocialVulnerability, self).__init__(incore_client)

    def run(self):
        """Execute the social vulnerability analysis using known parameters."""
        year = int(self.get_parameter('year'))
        state = self.get_parameter('state')
        county = self.get_parameter('county')
        census_geo_level = self.get_parameter('census_geo_level')

        self.social_vulnerability_model(year, state, county, census_geo_level)

    def social_vulnerability_model(self, year, state, county, census_geo_level):
        """

        Args:
            year (int): string indicating the year of the analysis
            state (str): string indicating the state containing relevant zones
            county (str): string indicating the county containing relevant zones
            census_geo_level (str): string indicating the relevant census geographic level

        Returns:

        """
        svu = SocialVulnerabilityUtil()
        state_number = svu.get_fips_code_for_state(state)

        # Reverse lookup if instead of state name an abbreviation is used for `state`
        if len(state) == 2:
            for key, state_dict in svu.STATE_FIPS_DICT.items():
                if state_dict['abbreviation'] == state.upper():
                    state = state_dict['name']

        county_number = self.county_list(state, state_number, county, year)

        if len(county_number) == 0:
            print("Invalid county name")
            sys.exit(0)

        geo_type = svu.get_geo_type(census_geo_level)

        if geo_type == None:
            print("invalid geographic level" + "\n" + 'only "Census Tract" and "Block Group" are acceptable levels' +
                  '\n' + 'Please enter "CT" or "BG" as input parameters fot the geo_type')
            sys.exit(0)

        # Compute demographic factors
        df_dem = self.demographic_factors(state_number, county_number, year, geo_type)

        # Compute national average values
        navs = self.national_ave_values(year)

        # Compute the social vulnerability index
        df_sv = self.compute_svs(df_dem, navs)

        # Save into a CSV file
        result_name = self.get_parameter("result_name")
        self.set_result_csv_data("sv_result", df_sv, name=result_name, source="dataframe")

    @staticmethod
    def county_list(state, state_number, county, year):
        """Obtain county list for a given set of parameters.

        Args:
            state (str): string containing the name of the state
            state_number (int): number assigned to the state
            county (str): string containing the name of the county
            year (int): year for the analysis

        Returns:
            A list of zones in a given county
        """
        county_list = censusdata.geographies(censusdata.censusgeo([('state', state_number), ('county', "*")]), "acs5",
                                             year)

        for key, county_dict in county_list.items():
            if key == county.title() + " County, " + state.title():
                return '%s' % (str(county_dict).split(':')[-1])

    @staticmethod
    def demographic_factors(state_number, county_number, year, geo_type, method="acs5"):
        """Obtain demographic factors required to compute the social vulnerability score of a zone.
        Args:
            state_number (int): number assigned to the state
            county_number (int): number assigned to the county
            year (int): number representing year of the analysis
            geo_type (str): string indicating the geographical level type
            method (str): string corresponding to the specific survey report

        Returns:
            pd.DataFrame: a dataframe with relevant demographic factors per geographic type
        """
        df_1 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo(
                                       [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                   ['B03002_001E', 'B03002_003E'],
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names1 = ['total_population', 'White alone_not Hispanic or Latino']
        df_1.columns = column_names1
        df_1['Factor 1: White, nonHispanic'] = df_1.apply(lambda row: row['White alone_not Hispanic or Latino'] /
                                                                      row['total_population'], axis=1)
        df_2 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo(
                                       [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                   ['B25003_001E', 'B25003_002E'],
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names2 = ['total', 'owner_occupied']
        df_2.columns = column_names2
        df_2['Factor 2: Home Owners'] = df_2.apply(lambda row: row['owner_occupied'] / row['total'], axis=1)

        df_3 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo(
                                       [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                   ['B17021_001E', 'B17021_002E'],
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names3 = ['total', 'persons in poverty']
        df_3.columns = column_names3
        df_3['Factor 3: earning higher than national poverty rate'] = df_3.apply(
            lambda row: 1 - (row['persons in poverty']
                             / row['total']), axis=1)

        column_ids4 = ['B15003_001E', 'B15003_017E', 'B15003_018E', 'B15003_019E', 'B15003_020E',
                       'B15003_021E', 'B15003_022E', 'B15003_023E', 'B15003_024E', 'B15003_025E']
        df_4 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo(
                                       [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                   column_ids4,
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names4 = ['total', 'Regular high school diploma', 'GED or alternative credential',
                         'Some college, less than 1 year', 'Some college, 1 or more years, no degree',
                         'Associate degree', 'Bachelor degree', 'Master degree', 'Professional school degree',
                         'Doctorate degree']
        df_4.columns = column_names4
        df_4['Factor 4: over 25 with high school diploma or higher'] = df_4.apply(
            lambda row: (row['Regular high school diploma'] +
                         row['GED or alternative credential'] +
                         row['Some college, less than 1 year'] +
                         row['Some college, 1 or more years, no degree'] +
                         row['Associate degree'] +
                         row['Bachelor degree'] +
                         row['Master degree'] +
                         row['Professional school degree'] +
                         row['Doctorate degree'])
                        / row['total'], axis=1)

        if geo_type == 'tract':
            column_ids5 = ['B18101_001E', 'B18101_011E', 'B18101_014E', 'B18101_030E', 'B18101_033E']
            df_5 = censusdata.download(method,
                                       year,
                                       censusdata.censusgeo(
                                           [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                       column_ids5,
                                       key="a991ff442db3b1971f5399f9133f5415a45df982")

            column_names5 = ['total', 'M 18-34 no disability', 'M 35-64 no disability', 'F 18-34 no disability',
                             'F 35-64 no disability']

            df_5.columns = column_names5
            df_5['Factor 5: without disability age 18 to 65'] = df_5.apply(lambda row: (row['M 18-34 no disability'] +
                                                                                        row['M 35-64 no disability'] +
                                                                                        row['F 18-34 no disability'] +
                                                                                        row['F 35-64 no disability']) /
                                                                                       row['total'], axis=1)
        elif geo_type == 'block group':
            column_ids5 = ['B01003_001E', 'C21007_006E', 'C21007_009E', 'C21007_013E', 'C21007_016E']
            df_5 = censusdata.download(method,
                                       year,
                                       censusdata.censusgeo(
                                           [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                       column_ids5,
                                       key="a991ff442db3b1971f5399f9133f5415a45df982")

            column_names5 = ['total', 'Vet below Pov 18-64 no disability', 'Vet above Pov 18-64 no disability',
                             'nonVet below Pov 18-64 no disability', 'nonVet above Pov 18-64 no disability']

            df_5.columns = column_names5
            df_5['Factor 5: without disability age 18 to 65'] = df_5.apply(
                lambda row: (row['Vet below Pov 18-64 no disability'] +
                             row['Vet above Pov 18-64 no disability'] +
                             row['nonVet below Pov 18-64 no disability'] +
                             row['nonVet above Pov 18-64 no disability']) / row['total'], axis=1)
        else:
            df_5 = {}

        df_wnh = df_1["Factor 1: White, nonHispanic"]
        df_how = df_2["Factor 2: Home Owners"]
        df_npr = df_3["Factor 3: earning higher than national poverty rate"]
        df_hsd = df_4["Factor 4: over 25 with high school diploma or higher"]
        df_wod = df_5["Factor 5: without disability age 18 to 65"]
        df = pd.concat([df_wnh, df_how, df_npr, df_hsd, df_wod], axis=1, join='inner')

        new_indices = []
        geo_type_names = []

        for index in df.index.tolist():
            if geo_type == "tract":
                new_index = index.geo[0][1] + index.geo[1][1] + index.geo[2][1]
            elif geo_type == "block group":
                new_index = index.geo[0][1] + index.geo[1][1] + index.geo[2][1] + index.geo[3][1]
            else:
                new_index = []

            new_indices.append(new_index)
            geo_type_name = index.name.split(',')[0]
            geo_type_names.append(geo_type_name)
        df.index = new_indices
        df.insert(0, '%s number' % geo_type, geo_type_names, True)

        return df

    @staticmethod
    def national_ave_values(year, method='acs5'):
        """Computation of the national average values for demographic features

        Args:
            year (int): number representing the year to analyze
            method (str): string indicating the survey referred to during analysis

        Returns:
            np.Array: array of national average values for demographic features
        """
        nav1 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo([('state', '*')]),
                                   ['B03002_001E', 'B03002_003E'],
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names1 = ['total_population', 'White alone_not Hispanic or Latino']
        nav1.columns = column_names1
        nav1.loc['USA'] = nav1.sum(numeric_only=True, axis=0)
        nav1['NAV-1: White, nonHispanic'] = nav1.apply(lambda row: row['White alone_not Hispanic or Latino'] /
                                                                   row['total_population'], axis=1)

        nav2 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo([('state', '*')]),
                                   ['B25003_001E', 'B25003_002E'],
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names2 = ['total', 'owner_occupied']
        nav2.columns = column_names2
        nav2.loc['USA'] = nav2.sum(numeric_only=True, axis=0)
        nav2['NAV-2: Home Owners'] = nav2.apply(lambda row: row['owner_occupied'] / row['total'], axis=1)

        nav3 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo([('state', '*')]),
                                   ['B17021_001E', 'B17021_002E'],
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names3 = ['total', 'persons in poverty']
        nav3.columns = column_names3
        nav3.loc['USA'] = nav3.sum(numeric_only=True, axis=0)
        nav3['NAV-3: earning higher than national poverty rate'] = nav3.apply(lambda row: 1 - (row['persons in poverty']
                                                                                               / row['total']), axis=1)

        column_ids4 = ['B15003_001E', 'B15003_017E', 'B15003_018E', 'B15003_019E', 'B15003_020E',
                       'B15003_021E', 'B15003_022E', 'B15003_023E', 'B15003_024E', 'B15003_025E']
        nav4 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo([('state', '*')]),
                                   column_ids4,
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names4 = ['total', 'Regular high school diploma', 'GED or alternative credential',
                         'Some college, less than 1 year', 'Some college, 1 or more years, no degree',
                         'Associate degree', 'Bachelor degree', 'Master degree', 'Professional school degree',
                         'Doctorate degree']
        nav4.columns = column_names4
        nav4.loc['USA'] = nav4.sum(numeric_only=True, axis=0)
        nav4['NAV-4: over 25 with high school diploma or higher'] = nav4.apply(
            lambda row: (row['Regular high school diploma'] +
                         row['GED or alternative credential'] +
                         row['Some college, less than 1 year'] +
                         row['Some college, 1 or more years, no degree'] +
                         row['Associate degree'] +
                         row['Bachelor degree'] +
                         row['Master degree'] +
                         row['Professional school degree'] +
                         row['Doctorate degree'])
                        / row['total'], axis=1)

        column_ids5 = ['B18101_001E', 'B18101_011E', 'B18101_014E', 'B18101_030E', 'B18101_033E']
        nav5 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo([('state', '*')]),
                                   column_ids5,
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names5 = ['total', 'M 18-34 no disability', 'M 35-64 no disability', 'F 18-34 no disability',
                         'F 35-64 no disability']
        nav5.columns = column_names5
        nav5.loc['USA'] = nav5.sum(numeric_only=True, axis=0)
        nav5['NAV-5: without disability age 18 to 65'] = nav5.apply(lambda row: (row['M 18-34 no disability'] +
                                                                                 row['M 35-64 no disability'] +
                                                                                 row['F 18-34 no disability'] +
                                                                                 row['F 35-64 no disability']) / row[
                                                                                    'total'], axis=1)
        navs = np.array([
            nav1.iloc[52]['NAV-1: White, nonHispanic'],
            nav2.iloc[52]['NAV-2: Home Owners'],
            nav3.iloc[52]['NAV-3: earning higher than national poverty rate'],
            nav4.iloc[52]['NAV-4: over 25 with high school diploma or higher'],
            nav5.iloc[52]['NAV-5: without disability age 18 to 65']
        ])

        return navs

    @staticmethod
    def compute_svs(df, navs):
        """ Computation of the social vulnerability score and corresponding zoning

        Args:
            df (pd.DataFrame): dataframe for the census geographic unit of interest
            navs (np.Array): numpy array containing national average values

        Returns:
            pd.DataFrame: Social vulnerability score and corresponding zoning data
        """
        df['R1'] = df['Factor 1: White, nonHispanic'] / navs[0]
        df['R2'] = df['Factor 2: Home Owners'] / navs[1]
        df['R3'] = df['Factor 3: earning higher than national poverty rate'] / navs[2]
        df['R4'] = df['Factor 4: over 25 with high school diploma or higher'] / navs[3]
        df['R5'] = df['Factor 5: without disability age 18 to 65'] / navs[4]
        df['SVS'] = df.apply(lambda row: (row['R1'] + row['R2'] + row['R3'] + row['R4'] + row['R5']) / 5, axis=1)

        maximum_nav = 1/navs
        std = abs(1 - (sum(maximum_nav) / len(maximum_nav))) / 3

        lb_2 = 1 - 1.5*std
        lb_1 = 1 - 0.5*std
        ub_1 = 1 + 0.5*std
        ub_2 = 1 + 1.5*std

        zones = []

        for svs in df['SVS'].tolist():
            if svs < lb_2:
                new_zone = 'High Vulnerable (zone5)'
            elif svs < lb_1:
                new_zone = 'Medium to High Vulnerable (zone4)'
            elif svs < ub_1:
                new_zone = 'Medium Vulnerable (zone3)'
            elif svs < ub_2:
                new_zone = 'Medium to Low Vulnerable (zone2)'
            elif svs > ub_2:
                new_zone = 'Low Vulnerable (zone1)'
            else:
                new_zone = 'No Data'
            zones.append(new_zone)

        df['zone'] = zones

        df = df.rename_axis('FIPS').sort_values(by='FIPS').reset_index()

        return df

    def get_spec(self):
        """Get specifications of the housing serial recovery model.

        Returns:
            obj: A JSON object of specifications of the social vulnerability model.

        """
        return {
            'name': 'social-vulnerability',
            'description': 'Social vulnerability score model',
            'input_parameters': [
                {
                    'id': 'result_name',
                    'required': True,
                    'description': 'Result CSV dataset name',
                    'type': str
                },
                {
                    'id': 'year',
                    'required': True,
                    'description': 'Year for which the analysis is computed',
                    'type': int
                },
                {
                    'id': 'state',
                    'required': True,
                    'description': 'State for which the anaysis is computed',
                    'type': str
                },
                {
                    'id': 'county',
                    'required': True,
                    'description': 'Country for which the analysis is computed',
                    'type': str
                },
                {
                    'id': 'census_geo_level',
                    'required': True,
                    'description': 'Census geographic level for which the analysis is computed',
                    'type': str
                }
            ],
            'input_datasets': [
            ],
            'output_datasets': [
                {
                    'id': 'sv_result',
                    'parent_type': 'social_vulnerability_score',
                    'description': 'A csv file with zones containing demographic factors'
                                   'qualified by a social vulnerability score',
                    'type': 'incore:socialVulnerabilityScore'
                }
            ]
        }
