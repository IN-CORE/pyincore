# Copyright (c) 2021 University of Illinois and others. All rights reserved.
#
# This program and the accompanying materials are made available under the
# terms of the Mozilla Public License v2.0 which accompanies this distribution,
# and is available at https://www.mozilla.org/en-US/MPL/2.0/

import numpy as np
import pandas as pd
import censusdata
import sys

from pyincore import BaseAnalysis
from pyincore.analyses.socialvulnerability.socialvulnerabilityutil import SocialVulnerabilityUtil

class SocialVulnerability(BaseAnalysis):
    """This analysis computes a social vulnerability score for per associated zone in census data.

    The output of the computation is a dataset CSV format.

    Contributors
        | Science: Elaina Sutley, Amin Enderami
        | Implementation:  Amin Enderami, Santiago Núñez-Corrales, and NCSA IN-CORE Dev Team

    Related publications
        Sutley, E.J. and Hamideh, S., 2020. Postdisaster housing stages: a Markov chain approach to model sequences
        and duration based on social vulnerability. Risk Analysis, 40(12), pp.2675-2695.

    Args:
        incore_client (IncoreClient): Service authentication.

    """

    def __init__(self, incore_client):
        super(SocialVulnerability, self).__init__(incore_client)

    def run(self):
        """Execute the social vulnerability analysis using known parameters."""
        year = str(self.get_parameter('year'))
        state = self.get_parameter('state')
        county = self.get_parameter('county')
        census_geo_level = self.get_parameter('census_geo_level')

        self.social_vulnerability_model(year, state, county, census_geo_level)

    def social_vulnerability_model(self, year, state, county, census_geo_level):
        """

        Args:
            year (str): string indicating the year of the analysis
            state (str): string indicating the state containing relevant zones
            county (str): string indicating the county containing relevant zones
            census_geo_level (str): string indicating the relevant census geographic level

        Returns:

        """
        svu = SocialVulnerabilityUtil()
        state_number = svu.get_fips_code_for_state(state)
        state_data = None

        # Use state abbreviations to find one matching (case insensitive) the target and stop
        if len(state) == 2:
            for key, state_dict in svu.STATE_FIPS_DICT.items():
                if state_dict['abbreviation'] == state.upper():
                    state_data = state_dict['name']
                    break

        county_number = self.county_list(state_data, state_number, county, year)

        if len(county_number) == 0:
            print("Invalid county name")
            sys.exit(0)

        geo_type = svu.get_geo_type(census_geo_level)

        if geo_type == None:
            print("invalid geographic level" + "\n" + 'only "Census Tract" and "Block Group" are acceptable levels' +
                  '\n' + 'Please enter "CT" or "BG" as input parameters fot the geo_type')
            sys.exit(0)

        # Compute demographic factors
        df_dem = self.demographic_factors(state_number, county_number, year, geo_type)

    @staticmethod
    def county_list(state_data, state_number, county, year):
        list = censusdata.geographies(censusdata.censusgeo([('state', state_number), ('county', "*")]), "acs5", year)

        county_number = ""
        for key, county_dict in list.items():
            if key == county.title() + " County, " + state_data.title():
                county_number = '%s' % (str(county_dict).split(':')[-1])
        return county_number

    @staticmethod
    def demographic_factors(state_number, county_number, year, geo_type, method="acs5"):
        """Obtain demographic factors required to compute the social vulnerability score of a zone.
        Args:
            state_number:
            county_number:
            year:
            geo_type:
            method:

        Returns:

        """
        df_1 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo(
                                       [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                   ['B03002_001E', 'B03002_003E'],
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names1 = ['total_population', 'White alone_not Hispanic or Latino']
        df_1.columns = column_names1
        df_1['Factor 1: White, nonHispanic'] = df_1.apply(lambda row: row['White alone_not Hispanic or Latino'] /
                                                                      row['total_population'], axis=1)
        df_2 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo(
                                       [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                   ['B25003_001E', 'B25003_002E'],
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names2 = ['total', 'owner_occupied']
        df_2.columns = column_names2
        df_2['Factor 2: Home Owners'] = df_2.apply(lambda row: row['owner_occupied'] / row['total'], axis=1)

        df_3 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo(
                                       [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                   ['B17021_001E', 'B17021_002E'],
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names3 = ['total', 'persons in poverty']
        df_3.columns = column_names3
        df_3['Factor 3: earning higher than national poverty rate'] = df_3.apply(
            lambda row: 1 - (row['persons in poverty']
                             / row['total']), axis=1)

        column_ids4 = ['B15003_001E', 'B15003_017E', 'B15003_018E', 'B15003_019E', 'B15003_020E',
                       'B15003_021E', 'B15003_022E', 'B15003_023E', 'B15003_024E', 'B15003_025E']
        df_4 = censusdata.download(method,
                                   year,
                                   censusdata.censusgeo(
                                       [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                   column_ids4,
                                   key="a991ff442db3b1971f5399f9133f5415a45df982")
        column_names4 = ['total', 'Regular high school diploma', 'GED or alternative credential',
                         'Some college, less than 1 year', 'Some college, 1 or more years, no degree',
                         'Associate degree', 'Bachelor degree', 'Master degree', 'Professional school degree',
                         'Doctorate degree']
        df_4.columns = column_names4
        df_4['Factor 4: over 25 with high school diploma or higher'] = df_4.apply(
            lambda row: (row['Regular high school diploma'] +
                         row['GED or alternative credential'] +
                         row['Some college, less than 1 year'] +
                         row['Some college, 1 or more years, no degree'] +
                         row['Associate degree'] +
                         row['Bachelor degree'] +
                         row['Master degree'] +
                         row['Professional school degree'] +
                         row['Doctorate degree'])
                        / row['total'], axis=1)

        if geo_type == 'tract':
            column_ids5 = ['B18101_001E', 'B18101_011E', 'B18101_014E', 'B18101_030E', 'B18101_033E']
            df_5 = censusdata.download(method,
                                       year,
                                       censusdata.censusgeo(
                                           [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                       column_ids5,
                                       key="a991ff442db3b1971f5399f9133f5415a45df982")

            column_names5 = ['total', 'M 18-34 no disability', 'M 35-64 no disability', 'F 18-34 no disability',
                             'F 35-64 no disability']

            df_5.columns = column_names5
            df_5['Factor 5: without disability age 18 to 65'] = df_5.apply(lambda row: (row['M 18-34 no disability'] +
                                                                                        row['M 35-64 no disability'] +
                                                                                        row['F 18-34 no disability'] +
                                                                                        row['F 35-64 no disability']) /
                                                                                       row['total'], axis=1)
        elif geo_type == 'block group':
            column_ids5 = ['B01003_001E', 'C21007_006E', 'C21007_009E', 'C21007_013E', 'C21007_016E']
            df_5 = censusdata.download(method,
                                       year,
                                       censusdata.censusgeo(
                                           [('state', state_number), ('county', county_number), (geo_type, '*')]),
                                       column_ids5,
                                       key="a991ff442db3b1971f5399f9133f5415a45df982")

            column_names5 = ['total', 'Vet below Pov 18-64 no disability', 'Vet above Pov 18-64 no disability',
                             'nonVet below Pov 18-64 no disability', 'nonVet above Pov 18-64 no disability']

            df_5.columns = column_names5
            df_5['Factor 5: without disability age 18 to 65'] = df_5.apply(
                lambda row: (row['Vet below Pov 18-64 no disability'] +
                             row['Vet above Pov 18-64 no disability'] +
                             row['nonVet below Pov 18-64 no disability'] +
                             row['nonVet above Pov 18-64 no disability']) / row['total'], axis=1)
        else:
            df_5 = {}

        df_wnh = df_1["Factor 1: White, nonHispanic"]
        df_how = df_2["Factor 2: Home Owners"]
        df_npr = df_3["Factor 3: earning higher than national poverty rate"]
        df_hsd = df_4["Factor 4: over 25 with high school diploma or higher"]
        df_wod = df_5["Factor 5: without disability age 18 to 65"]
        df_t = pd.concat([df_wnh, df_how, df_npr, df_hsd, df_wod], axis=1, join='inner')

        new_indices = []
        geo_type_names = []

        for index in df_t.index.tolist():
            if geo_type == "tract":
                new_index = index.geo[0][1] + index.geo[1][1] + index.geo[2][1]
            elif geo_type == "block group":
                new_index = index.geo[0][1] + index.geo[1][1] + index.geo[2][1] + index.geo[3][1]
            else:
                new_index = []

            new_indices.append(new_index)
            geo_type_name = index.name.split(',')[0]
            geo_type_names.append(geo_type_name)
        df_t.index = new_indices
        df_t.insert(0, '%s number' % geo_type, geo_type_names, True)

        return df_t

    def get_spec(self):
        """Get specifications of the housing serial recovery model.

        Returns:
            obj: A JSON object of specifications of the social vulnerability model.

        """
        return {
            'name': 'social-vulnerability',
            'description': 'Social vulnerability score model',
            'input_parameters': [
                {
                    'id': 'result_name',
                    'required': True,
                    'description': 'Result CSV dataset name',
                    'type': str
                },
                {
                    'id': 'year',
                    'required': True,
                    'description': 'Year for which the analysis is computed',
                    'type': int
                },
                {
                    'id': 'state',
                    'required': True,
                    'description': 'State for which the anaysis is computed',
                    'type': str
                },
                {
                    'id': 'county',
                    'required': True,
                    'description': 'Country for which the analysis is computed',
                    'type': str
                },
                {
                    'id': 'census_geo_level',
                    'required': True,
                    'description': 'Census geographic level for which the analysis is computed',
                    'type': str
                }
            ],
            'input_datasets': [
            ],
            'output_datasets': [
                {
                    'id': 'ds_result',
                    'parent_type': 'social_vulnerability_score',
                    'description': 'A csv file with zones containing demographic factors'
                                   'qualified by a social vulnerability score',
                    'type': 'incore:socialVulnerabilityScore'
                }
            ]
        }
